"""
Kōan -- Plan runner.

Generates structured implementation plans and posts them as GitHub issues
or comments. Extracted from the /plan skill handler so it can run as a
queued mission via run.py instead of inline in the bridge process.

Issue-centric workflow:
  - New idea: search for existing plan issue first, update if found, create if not
  - Existing issue URL: read all comments, produce updated plan, post as comment
  - Always reuse existing issues to keep the conversation in one place

CLI:
    python3 -m app.plan_runner --project-path <path> --idea "Add dark mode"
    python3 -m app.plan_runner --project-path <path> --issue-url <url>
"""

import json
import re
import sys
from pathlib import Path
from typing import Optional, Tuple

from app.github import run_gh, issue_create, api, fetch_issue_with_comments
from app.prompts import load_prompt, load_skill_prompt


# GitHub issue URL pattern
_ISSUE_URL_RE = re.compile(
    r"https?://github\.com/(?P<owner>[^/]+)/(?P<repo>[^/]+)/issues/(?P<number>\d+)"
)

# Label used to tag plan issues for searchability
_PLAN_LABEL = "plan"


def run_plan(
    project_path: str,
    idea: Optional[str] = None,
    issue_url: Optional[str] = None,
    notify_fn=None,
    skill_dir: Optional[Path] = None,
    context: Optional[str] = None,
) -> Tuple[bool, str]:
    """Execute the plan pipeline.

    Either generates a new plan (idea mode) or iterates on an existing
    issue (issue_url mode). Exactly one of idea or issue_url must be set.

    Args:
        context: Optional additional user context (e.g. "Focus on phase 2").
                 Appended to the issue context or passed to plan generation.

    Returns:
        (success, summary) tuple.
    """
    if notify_fn is None:
        from app.notify import send_telegram
        notify_fn = send_telegram

    if issue_url:
        return _run_issue_plan(
            project_path, issue_url, notify_fn, skill_dir, context=context,
        )
    elif idea:
        return _run_new_plan(
            project_path, idea, notify_fn, skill_dir, context=context,
        )
    else:
        return False, "No idea or issue URL provided."


def _run_new_plan(
    project_path: str,
    idea: str,
    notify_fn,
    skill_dir: Optional[Path],
    context: Optional[str] = None,
) -> Tuple[bool, str]:
    """Generate a plan for a new idea, reusing an existing issue if found."""
    notify_fn(f"\U0001f9e0 Planning: {idea[:100]}{'...' if len(idea) > 100 else ''}")

    # Check for an existing plan issue before generating
    owner, repo = _get_repo_info(project_path)
    if owner and repo:
        existing = _search_existing_issue(owner, repo, idea)
        if existing:
            issue_number, issue_title = existing
            issue_url = (
                f"https://github.com/{owner}/{repo}/issues/{issue_number}"
            )
            notify_fn(
                f"\U0001f504 Found existing issue #{issue_number}: "
                f"{issue_title[:60]} — iterating"
            )
            return _run_issue_plan(
                project_path, issue_url, notify_fn, skill_dir, context=context,
            )

    try:
        plan = _generate_plan(
            project_path, idea, context=context or "", skill_dir=skill_dir,
        )
    except Exception as e:
        return False, f"Plan generation failed: {str(e)[:300]}"

    if not plan:
        return False, "Claude returned an empty plan."

    if not owner or not repo:
        notify_fn(f"Plan (no GitHub repo found, showing inline):\n\n{plan[:3500]}")
        return True, "Plan generated (no GitHub repo, sent inline)."

    title = _extract_title(plan)
    # Strip the title line from the plan body (it's now the issue title)
    plan_body = _strip_title_line(plan)
    issue_body = f"{plan_body}\n\n---\n*Generated by Kōan /plan*"

    try:
        result_url = issue_create(
            title, issue_body, labels=[_PLAN_LABEL], cwd=project_path
        )
    except Exception as e:
        # Label may not exist — retry without label
        try:
            result_url = issue_create(title, issue_body, cwd=project_path)
        except Exception as e2:
            notify_fn(
                f"\u26a0\ufe0f Plan ready but issue creation failed "
                f"({e2}):\n\n{plan[:3000]}"
            )
            return True, f"Plan generated but issue creation failed: {e2}"

    notify_fn(f"\u2705 Plan created: {result_url}")
    return True, f"Plan created: {result_url}"


def _run_issue_plan(
    project_path: str,
    issue_url: str,
    notify_fn,
    skill_dir: Optional[Path],
    context: Optional[str] = None,
) -> Tuple[bool, str]:
    """Read an existing issue + comments, generate updated plan, post comment."""
    match = _ISSUE_URL_RE.search(issue_url)
    if not match:
        return False, f"Invalid issue URL: {issue_url}"

    owner = match.group("owner")
    repo = match.group("repo")
    issue_number = match.group("number")

    notify_fn(f"\U0001f4d6 Reading issue #{issue_number} ({owner}/{repo})...")

    try:
        title, body, comments = _fetch_issue_context(owner, repo, issue_number)
    except Exception as e:
        return False, f"Failed to fetch issue: {str(e)[:300]}"

    # Build full issue context for the iteration prompt
    context_parts = [f"## Original Issue #{issue_number}: {title}\n\n{body}"]
    if comments:
        context_parts.append(f"\n\n## Discussion Comments\n\n{comments}")
    else:
        context_parts.append("\n\n*No comments yet on this issue.*")
    if context:
        context_parts.append(f"\n\n## User Instructions\n\n{context}")
    issue_context = "\n".join(context_parts)

    try:
        plan = _generate_iteration_plan(
            project_path, issue_context, skill_dir=skill_dir
        )
    except Exception as e:
        return False, f"Plan generation failed: {str(e)[:300]}"

    if not plan:
        return False, "Claude returned an empty plan."

    # Post as a comment on the issue
    iteration_title = _extract_title(plan)
    plan_body = _strip_title_line(plan)
    comment_body = (
        f"## {iteration_title}\n\n{plan_body}\n\n---\n"
        f"*Generated by Kōan /plan — iteration on existing issue*"
    )

    try:
        _comment_on_issue(owner, repo, issue_number, comment_body)
    except Exception as e:
        notify_fn(f"Plan ready but comment failed ({e}):\n\n{plan[:3000]}")
        return True, f"Plan generated but comment failed: {e}"

    issue_label = f"#{issue_number}"
    if title:
        issue_label = f"#{issue_number} ({title[:60]})"
    result_url = f"https://github.com/{owner}/{repo}/issues/{issue_number}"
    notify_fn(f"\u2705 Plan posted as comment on {issue_label}: {result_url}")
    return True, f"Plan posted on {issue_label}: {result_url}"


# ---------------------------------------------------------------------------
# Internal helpers
# ---------------------------------------------------------------------------

def _generate_plan(project_path, idea, context="", skill_dir=None):
    """Run Claude to generate a structured plan for a new idea."""
    if skill_dir is not None:
        prompt = load_skill_prompt(skill_dir, "plan", IDEA=idea, CONTEXT=context)
    else:
        prompt = load_prompt("plan", IDEA=idea, CONTEXT=context)

    return _run_claude_plan(prompt, project_path)


def _generate_iteration_plan(project_path, issue_context, skill_dir=None):
    """Run Claude to generate an updated plan based on issue + comments."""
    if skill_dir is not None:
        prompt = load_skill_prompt(
            skill_dir, "plan-iterate", ISSUE_CONTEXT=issue_context
        )
    else:
        prompt = load_prompt("plan-iterate", ISSUE_CONTEXT=issue_context)

    return _run_claude_plan(prompt, project_path)


# Regex matching preamble transition lines — everything up to and including
# such a line is stripped from the CLI output so it doesn't pollute the
# GitHub issue body.
_PREAMBLE_RE = re.compile(
    r"(?:now I have (?:all )?the context|"
    r"let me create the (?:comprehensive |structured )?plan|"
    r"here(?:'s| is) the (?:comprehensive |structured |implementation )?plan|"
    r"I'll create the plan|"
    r"let me (?:now )?(?:generate|write|draft|produce) the plan)",
    re.IGNORECASE,
)


def _strip_preamble(output: str) -> str:
    """Strip CLI exploration noise from the beginning of plan output.

    Some CLI providers (notably Copilot) include tool-call output and
    thinking text before the actual plan content. This function finds the
    last preamble transition line and returns only the plan that follows.
    """
    if not output:
        return output

    lines = output.splitlines()

    # Find the last line that matches a known preamble pattern.
    # Everything up to and including that line is noise.
    last_preamble_idx = -1
    for i, line in enumerate(lines):
        if _PREAMBLE_RE.search(line):
            last_preamble_idx = i

    if last_preamble_idx >= 0:
        remaining = "\n".join(lines[last_preamble_idx + 1:]).strip()
        if remaining:
            return remaining

    return output


def _is_error_output(output: str) -> bool:
    """Detect CLI error patterns in output that should not be posted as a plan."""
    if not output:
        return False
    # Claude CLI emits this when --max-turns is exhausted
    if "Reached max turns" in output:
        return True
    # Other known error patterns
    if output.lstrip().startswith("Error:") and len(output) < 200:
        return True
    return False


def _run_claude_plan(prompt, project_path):
    """Execute Claude CLI with the given prompt and return the output."""
    from app.cli_provider import run_command
    output = run_command(
        prompt, project_path,
        allowed_tools=["Read", "Glob", "Grep", "WebFetch"],
        max_turns=25, timeout=600,
    )
    if _is_error_output(output):
        raise RuntimeError(output)
    return _strip_preamble(output)


def _search_existing_issue(owner, repo, idea):
    """Search for an existing open plan issue that matches the idea.

    Returns (issue_number, title) if found, None otherwise.
    """
    # Build search keywords from the idea (first few significant words)
    keywords = _extract_search_keywords(idea)
    if not keywords:
        return None

    search_query = f"repo:{owner}/{repo} is:issue is:open {keywords}"
    try:
        result_json = api(
            "search/issues",
            extra_args=["--jq", '.items[:5] | [.[] | {number, title}]',
                         "-f", f"q={search_query}",
                         "-f", "per_page=5"],
        )
        results = json.loads(result_json)
        if not isinstance(results, list) or not results:
            return None

        # Return the first match
        hit = results[0]
        return str(hit.get("number", "")), hit.get("title", "")
    except Exception as e:
        print(f"[plan_runner] Issue search failed: {e}", file=sys.stderr)
        return None


def _extract_search_keywords(idea):
    """Extract meaningful search keywords from an idea string."""
    # Remove common filler words, keep the substance
    stop_words = {
        "a", "an", "the", "is", "are", "was", "were", "be", "been", "being",
        "have", "has", "had", "do", "does", "did", "will", "would", "could",
        "should", "may", "might", "can", "shall", "to", "of", "in", "for",
        "on", "with", "at", "by", "from", "as", "into", "about", "between",
        "through", "and", "but", "or", "not", "no", "so", "if", "then",
        "that", "this", "it", "its", "we", "our", "i", "my", "me", "you",
        "your", "they", "them", "their", "let", "lets", "let's", "need",
        "want", "add", "make", "get", "set", "use", "like",
    }
    words = re.findall(r'\b[a-zA-Z]{2,}\b', idea.lower())
    keywords = [w for w in words if w not in stop_words]
    # Take first 4 meaningful keywords for search
    return " ".join(keywords[:4])


def _get_repo_info(project_path):
    """Get GitHub owner/repo from a local git repo."""
    try:
        output = run_gh("repo", "view", "--json", "owner,name",
                        cwd=project_path, timeout=15)
        data = json.loads(output)
        owner = data.get("owner", {}).get("login", "")
        repo = data.get("name", "")
        if owner and repo:
            return owner, repo
    except Exception as e:
        print(f"[plan_runner] Repo info fetch failed: {e}", file=sys.stderr)
    return None, None


def _fetch_issue_context(owner, repo, issue_number):
    """Fetch issue title, body and comments via gh CLI."""
    title, body, comments = fetch_issue_with_comments(owner, repo, issue_number)
    comments_text = _format_comments(comments)
    return title, body, comments_text


def _format_comments(comments):
    """Format comments list into readable text with authorship.

    Args:
        comments: List of dicts with keys: author, date, body.
    """
    if not isinstance(comments, list) or not comments:
        return ""

    parts = []
    for c in comments:
        author = c.get("author", "unknown")
        date = c.get("date", "")[:10]
        body = c.get("body", "").strip()
        if body:
            parts.append(f"**{author}** ({date}):\n{body}")
    return "\n\n---\n\n".join(parts)


def _comment_on_issue(owner, repo, issue_number, body):
    """Post a comment on an existing GitHub issue."""
    api(
        f"repos/{owner}/{repo}/issues/{issue_number}/comments",
        input_data=body,
    )


def _extract_title(plan_text):
    """Extract the title from the first non-empty line of the plan.

    The plan prompt instructs Claude to write a short, descriptive title
    as the very first line (no # prefix). This function extracts that line,
    stripping any accidental markdown formatting or CLI noise characters.
    """
    lines = plan_text.strip().splitlines()
    for line in lines:
        line = line.strip()
        if not line:
            continue
        # Strip any markdown heading prefix the model may have added
        clean = re.sub(r'^#+\s*', '', line).strip()
        # Strip CLI noise characters (bullets, arrows, decorative prefixes)
        clean = re.sub(r'^[●•►▸▹▶◆◇○◎▪▫→⟶»>]+\s*', '', clean).strip()
        # Skip generic section headings that aren't real titles
        if clean.lower() in (
            "summary", "implementation plan", "plan",
            "open questions", "implementation steps",
            "implementation phases",
        ):
            continue
        if clean:
            return clean[:120]
    return "Implementation Plan"


def _strip_title_line(plan_text):
    """Remove the first non-empty line (title) from the plan text.

    The title is used as the GitHub issue title, so we strip it from the
    body to avoid duplication.
    """
    lines = plan_text.strip().splitlines()
    # Find and skip the first non-empty line
    for i, line in enumerate(lines):
        if line.strip():
            remaining = "\n".join(lines[i + 1:]).strip()
            return remaining if remaining else plan_text
    return plan_text


def _extract_idea_from_issue(body):
    """Extract the core idea from an issue body for re-planning."""
    if not body:
        return "Review and update this plan"
    lines = body.strip().splitlines()
    for line in lines:
        line = line.strip()
        if not line:
            continue
        if line.startswith("---") or line.startswith("*Generated by"):
            continue
        clean = re.sub(r'^#+\s*', '', line).strip()
        clean = re.sub(r'^Plan:\s*', '', clean).strip()
        if clean and len(clean) > 3:
            return clean[:500]
    return "Review and refine this plan based on the discussion"


# ---------------------------------------------------------------------------
# CLI entry point -- python3 -m app.plan_runner
# ---------------------------------------------------------------------------

def main(argv=None):
    """CLI entry point for plan_runner.

    Returns exit code (0 = success, 1 = failure).
    """
    import argparse
    import sys

    parser = argparse.ArgumentParser(
        description="Generate a structured plan and post as GitHub issue/comment."
    )
    parser.add_argument(
        "--project-path", required=True,
        help="Local path to the project repository",
    )
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument(
        "--idea",
        help="New idea to plan",
    )
    group.add_argument(
        "--issue-url",
        help="GitHub issue URL to iterate on",
    )
    parser.add_argument(
        "--context",
        help="Additional user context (e.g. 'Focus on phase 2')",
    )
    cli_args = parser.parse_args(argv)

    skill_dir = Path(__file__).resolve().parent.parent / "skills" / "core" / "plan"

    success, summary = run_plan(
        project_path=cli_args.project_path,
        idea=cli_args.idea,
        issue_url=cli_args.issue_url,
        skill_dir=skill_dir,
        context=cli_args.context,
    )
    print(summary)
    return 0 if success else 1


if __name__ == "__main__":
    import sys
    sys.exit(main())
