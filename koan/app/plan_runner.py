"""
Kōan -- Plan runner.

Generates structured implementation plans and posts them as GitHub issues
or comments. Extracted from the /plan skill handler so it can run as a
queued mission via run.sh instead of inline in the bridge process.

CLI:
    python3 -m app.plan_runner --project-path <path> --idea "Add dark mode"
    python3 -m app.plan_runner --project-path <path> --issue-url <url>
"""

import json
import re
import subprocess
from pathlib import Path
from typing import Optional, Tuple

from app.github import run_gh, issue_create, api


# GitHub issue URL pattern
_ISSUE_URL_RE = re.compile(
    r"https?://github\.com/(?P<owner>[^/]+)/(?P<repo>[^/]+)/issues/(?P<number>\d+)"
)


def run_plan(
    project_path: str,
    idea: Optional[str] = None,
    issue_url: Optional[str] = None,
    notify_fn=None,
    skill_dir: Optional[Path] = None,
) -> Tuple[bool, str]:
    """Execute the plan pipeline.

    Either generates a new plan (idea mode) or iterates on an existing
    issue (issue_url mode). Exactly one of idea or issue_url must be set.

    Returns:
        (success, summary) tuple.
    """
    if notify_fn is None:
        from app.notify import send_telegram
        notify_fn = notify_fn or send_telegram

    if issue_url:
        return _run_issue_plan(project_path, issue_url, notify_fn, skill_dir)
    elif idea:
        return _run_new_plan(project_path, idea, notify_fn, skill_dir)
    else:
        return False, "No idea or issue URL provided."


def _run_new_plan(
    project_path: str,
    idea: str,
    notify_fn,
    skill_dir: Optional[Path],
) -> Tuple[bool, str]:
    """Generate a plan for a new idea and create a GitHub issue."""
    notify_fn(f"\U0001f9e0 Planning: {idea[:100]}{'...' if len(idea) > 100 else ''}")

    try:
        plan = _generate_plan(project_path, idea, skill_dir=skill_dir)
    except Exception as e:
        return False, f"Plan generation failed: {str(e)[:300]}"

    if not plan:
        return False, "Claude returned an empty plan."

    # Create GitHub issue
    owner, repo = _get_repo_info(project_path)
    if not owner or not repo:
        notify_fn(f"Plan (no GitHub repo found, showing inline):\n\n{plan[:3500]}")
        return True, "Plan generated (no GitHub repo, sent inline)."

    title = _extract_title(plan)
    issue_body = f"## Plan: {idea}\n\n{plan}\n\n---\n*Generated by Kōan /plan*"

    try:
        issue_url = issue_create(title, issue_body, cwd=project_path)
    except Exception as e:
        notify_fn(f"\u26a0\ufe0f Plan ready but issue creation failed ({e}):\n\n{plan[:3000]}")
        return True, f"Plan generated but issue creation failed: {e}"

    notify_fn(f"\u2705 Plan created: {issue_url}")
    return True, f"Plan created: {issue_url}"


def _run_issue_plan(
    project_path: str,
    issue_url: str,
    notify_fn,
    skill_dir: Optional[Path],
) -> Tuple[bool, str]:
    """Read an existing issue + comments, generate updated plan, post comment."""
    match = _ISSUE_URL_RE.search(issue_url)
    if not match:
        return False, f"Invalid issue URL: {issue_url}"

    owner = match.group("owner")
    repo = match.group("repo")
    issue_number = match.group("number")

    notify_fn(f"\U0001f4d6 Reading issue #{issue_number} ({owner}/{repo})...")

    try:
        title, body, comments = _fetch_issue_context(owner, repo, issue_number)
    except Exception as e:
        return False, f"Failed to fetch issue: {str(e)[:300]}"

    # Build context from issue body + comments
    context_parts = [f"## Original Issue #{issue_number}: {title}\n\n{body}"]
    if comments:
        context_parts.append(f"\n\n## Comments\n\n{comments}")
    context = "\n".join(context_parts)

    idea = _extract_idea_from_issue(body)

    try:
        plan = _generate_plan(
            project_path, idea, context=context, skill_dir=skill_dir
        )
    except Exception as e:
        return False, f"Plan generation failed: {str(e)[:300]}"

    if not plan:
        return False, "Claude returned an empty plan."

    # Post as a comment on the issue
    comment_body = (
        f"## Updated Plan\n\n{plan}\n\n---\n"
        f"*Generated by Kōan /plan — iteration on existing issue*"
    )

    try:
        _comment_on_issue(owner, repo, issue_number, comment_body)
    except Exception as e:
        notify_fn(f"Plan ready but comment failed ({e}):\n\n{plan[:3000]}")
        return True, f"Plan generated but comment failed: {e}"

    issue_label = f"#{issue_number}"
    if title:
        issue_label = f"#{issue_number} ({title[:60]})"
    result_url = f"https://github.com/{owner}/{repo}/issues/{issue_number}"
    notify_fn(f"\u2705 Plan posted as comment on {issue_label}: {result_url}")
    return True, f"Plan posted on {issue_label}: {result_url}"


# ---------------------------------------------------------------------------
# Internal helpers
# ---------------------------------------------------------------------------

def _generate_plan(project_path, idea, context="", skill_dir=None):
    """Run Claude to generate a structured plan."""
    if skill_dir is not None:
        from app.prompts import load_skill_prompt
        prompt = load_skill_prompt(skill_dir, "plan", IDEA=idea, CONTEXT=context)
    else:
        from app.prompts import load_prompt
        prompt = load_prompt("plan", IDEA=idea, CONTEXT=context)

    from app.cli_provider import build_full_command
    from app.config import get_model_config

    models = get_model_config()
    cmd = build_full_command(
        prompt=prompt,
        allowed_tools=["Read", "Glob", "Grep", "WebFetch"],
        model=models.get("chat", ""),
        fallback=models.get("fallback", ""),
        max_turns=3,
    )

    result = subprocess.run(
        cmd,
        capture_output=True, text=True, timeout=300,
        cwd=project_path,
    )

    if result.returncode != 0:
        raise RuntimeError(f"Claude plan generation failed: {result.stderr[:300]}")

    return result.stdout.strip()


def _get_repo_info(project_path):
    """Get GitHub owner/repo from a local git repo."""
    try:
        output = run_gh("repo", "view", "--json", "owner,name",
                        cwd=project_path, timeout=15)
        data = json.loads(output)
        owner = data.get("owner", {}).get("login", "")
        repo = data.get("name", "")
        if owner and repo:
            return owner, repo
    except Exception:
        pass
    return None, None


def _fetch_issue_context(owner, repo, issue_number):
    """Fetch issue title, body and comments via gh CLI."""
    issue_json = api(
        f"repos/{owner}/{repo}/issues/{issue_number}",
        jq='{"title": .title, "body": .body}',
    )
    try:
        data = json.loads(issue_json)
        title = data.get("title", "")
        body = data.get("body", "")
    except (json.JSONDecodeError, TypeError):
        title = ""
        body = issue_json

    comments_json = api(
        f"repos/{owner}/{repo}/issues/{issue_number}/comments",
        jq='[.[] | {author: .user.login, date: .created_at, body: .body}]',
    )

    comments_text = _format_comments(comments_json)
    return title, body, comments_text


def _format_comments(comments_json):
    """Format comments JSON into readable text with authorship."""
    try:
        comments = json.loads(comments_json)
        if not isinstance(comments, list) or not comments:
            return ""
    except (json.JSONDecodeError, TypeError):
        return comments_json.strip() if comments_json else ""

    parts = []
    for c in comments:
        author = c.get("author", "unknown")
        date = c.get("date", "")[:10]
        body = c.get("body", "").strip()
        if body:
            parts.append(f"**{author}** ({date}):\n{body}")
    return "\n\n---\n\n".join(parts)


def _comment_on_issue(owner, repo, issue_number, body):
    """Post a comment on an existing GitHub issue."""
    api(
        f"repos/{owner}/{repo}/issues/{issue_number}/comments",
        input_data=body,
    )


def _extract_title(plan_text):
    """Extract a short title from the plan for the issue title."""
    lines = plan_text.strip().splitlines()
    for line in lines:
        line = line.strip()
        if not line:
            continue
        if line.startswith("#"):
            title = re.sub(r'^#+\s*', '', line).strip()
            if title:
                return title[:120]
        clean = re.sub(r'^[#*>\-]+\s*', '', line).strip()
        if clean:
            return clean[:120]
    return "Implementation Plan"


def _extract_idea_from_issue(body):
    """Extract the core idea from an issue body for re-planning."""
    if not body:
        return "Review and update this plan"
    lines = body.strip().splitlines()
    for line in lines:
        line = line.strip()
        if not line:
            continue
        if line.startswith("---") or line.startswith("*Generated by"):
            continue
        clean = re.sub(r'^#+\s*', '', line).strip()
        clean = re.sub(r'^Plan:\s*', '', clean).strip()
        if clean and len(clean) > 3:
            return clean[:500]
    return "Review and refine this plan based on the discussion"


# ---------------------------------------------------------------------------
# CLI entry point -- python3 -m app.plan_runner
# ---------------------------------------------------------------------------

def main(argv=None):
    """CLI entry point for plan_runner.

    Returns exit code (0 = success, 1 = failure).
    """
    import argparse
    import sys

    parser = argparse.ArgumentParser(
        description="Generate a structured plan and post as GitHub issue/comment."
    )
    parser.add_argument(
        "--project-path", required=True,
        help="Local path to the project repository",
    )
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument(
        "--idea",
        help="New idea to plan",
    )
    group.add_argument(
        "--issue-url",
        help="GitHub issue URL to iterate on",
    )
    cli_args = parser.parse_args(argv)

    skill_dir = Path(__file__).resolve().parent.parent / "skills" / "core" / "plan"

    success, summary = run_plan(
        project_path=cli_args.project_path,
        idea=cli_args.idea,
        issue_url=cli_args.issue_url,
        skill_dir=skill_dir,
    )
    print(summary)
    return 0 if success else 1


if __name__ == "__main__":
    import sys
    sys.exit(main())
